<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Guidoc &mdash; Guidoc 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/project.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link href='//fonts.googleapis.com/css?family=Kreon:400,300,700' rel='stylesheet' type='text/css'>

   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="guidoc">
<h1>Guidoc<a class="headerlink" href="#guidoc" title="Permalink to this headline">¶</a></h1>
<p>Guidoc is a Python package that allows you to create <a class="reference external" href="https://wiki.python.org/moin/TkInter">Tkinter</a> widget layouts using a simple <a class="reference internal" href="#docstring-specification">docstring specification</a>. It can be used dynamically with docstrings passed to a class decorator or to statically generate a layout method from a specification file. The specification lets you describe a widget hierarchy in a compact form with a simple indented list. This is also used to compactly describe menus. When the docutils package is installed, grid layouts can be described using ASCII tables to visually indicate where widgets are located and how they span rows or columns.</p>
<p>Guidoc saves you from the challenge of writing and managing complex Tkinter layouts. You can easily see the parent-child relationships between widgets and menu items and change the hierarchy with ease. Grid layouts are easy to modify at a later date without having to decipher the long forgotten row and column indices.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Tkinter</span> <span class="kn">as</span> <span class="nn">tk</span>
<span class="kn">from</span> <span class="nn">guidoc</span> <span class="kn">import</span> <span class="n">tk_layout</span>

<span class="nd">@tk_layout</span><span class="p">(</span><span class="s">r&#39;&#39;&#39;</span>
<span class="s">btnA(Button | text=&#39;Button A&#39;)</span>
<span class="s">btnB(Button | text=&#39;Button B&#39;)</span>
<span class="s">btnC(Button | text=&#39;Button C\n(spanning two columns)&#39;)</span>
<span class="s">frmX(Frame)</span>
<span class="s">  lbl1(Label | text=&#39;Widgets default&#39;, bg=&#39;red&#39;)</span>
<span class="s">  lbl2(Label | text=&#39;to using the pack&#39;, bg=&#39;white&#39;)</span>
<span class="s">  lbl3(Label | text=&#39;geometry manager&#39;, bg=&#39;blue&#39;, fg=&#39;white&#39;)</span>

<span class="s">[grid]    # Grid layout for the top level widgets</span>

<span class="s">+-----+------+------+</span>
<span class="s">|btnA | btnB |      |</span>
<span class="s">+-----+------+ frmX |</span>
<span class="s">|    btnC    |      |</span>
<span class="s">+------------+------+</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyApp</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_build_widgets</span><span class="p">()</span>  <span class="c"># This method is generated by tk_layout()</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Tk</span><span class="p">()</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>
</div>
<p>This gives rise to the following mockup:</p>
<img alt="_images/splash.png" src="_images/splash.png" />
<p>What happens here is the <tt class="docutils literal"><span class="pre">tk_layout</span></tt> decorator parses the Guidoc specification string and inserts the <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> method into the <tt class="docutils literal"><span class="pre">MyApp</span></tt> class. Calling the method in the initialization code adds all of the widget and menu items declared in the specification.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The examples in this documentation use Python 2.7 syntax. The &#8220;Tkinter&#8221; library was renamed to &#8220;tkinter&#8221; in Python 3.x.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">guidoc.py</span></tt> file functions as a standalone module and can be directly copied into your projects. It also functions as a <a class="reference internal" href="#command-line-tool-for-static-code-generation">command line tool for static code generation</a>.</p>
<p>With no command line arguments the <tt class="docutils literal"><span class="pre">guidoc.py</span></tt> module will launch a demo app:</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; guidoc
</pre></div>
</div>
<img alt="_images/demo.png" src="_images/demo.png" />
<p>You should be somewhat familiar with Tkinter. Guidoc simplifies some of the labor involved in creating a Tkinter application but you need to know how to write the code that connects the widgets together and makes them useful. This documentation will not teach you how to use Tkinter.</p>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>Guidoc requires either Python 2.7 or Python 3.x and no additional libraries.
It is recommended that you install the <a class="reference external" href="http://docutils.sourceforge.net/">docutils</a> package needed to parse
tabular grid layouts.</p>
<p>The installation script depends on setuptools which will be installed if it
isn&#8217;t currently present in your Python distribution. The source is written in
Python 2.7 syntax but will convert cleanly to Python 3 when the installer
passes it through 2to3.</p>
</div>
<div class="section" id="licensing">
<h2>Licensing<a class="headerlink" href="#licensing" title="Permalink to this headline">¶</a></h2>
<p>Guidoc is licensed for free commercial and non-commercial use under the terms of the MIT license.</p>
</div>
<div class="section" id="download">
<h2>Download<a class="headerlink" href="#download" title="Permalink to this headline">¶</a></h2>
<p>You can access the Guidoc Git repository from <a class="reference external" href="https://github.com/kevinpt/guidoc">Github</a>. You can install direct from PyPI with the &#8220;pip&#8221;
command if you have it available.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Guidoc is a Python package. You must have Python installed first to use it. Most modern Linux distributions and OS/X have it available by default. There are a number of options available for Windows. If you don&#8217;t already have a favorite, I recommend getting one of the <a class="reference external" href="http://www.scipy.org/install.html">&#8220;full-stack&#8221; Python distros</a> that are geared toward scientific computing such as Anaconda or Python(x,y).</p>
<p>If your OS has a package manager, it may be preferable to install Python setuptools through that tool before attempting to install Guidoc. Otherwise, the installation script will install these packages directly without registering them with the OS package manager.</p>
<p>The easiest way to install Guidoc is from <a class="reference external" href="https://pypi.python.org/pypi/guidoc">PyPI</a>.</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; pip install --upgrade guidoc
</pre></div>
</div>
<p>This will download and install the latest release, upgrading if you already have it installed. If you don&#8217;t have <tt class="docutils literal"><span class="pre">pip</span></tt> you may have the <tt class="docutils literal"><span class="pre">easy_install</span></tt> command available which can be used to install <tt class="docutils literal"><span class="pre">pip</span></tt> on your system:</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; easy_install pip
</pre></div>
</div>
<p>You can also use <tt class="docutils literal"><span class="pre">pip</span></tt> to get the latest development code from Github:</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; pip install --upgrade https://github.com/kevinpt/guidoc/tarball/master
</pre></div>
</div>
<p>If you manually downloaded a source package or created a clone with Git you can install Guidoc with the following command run from the base Guidoc directory:</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; python setup.py install
</pre></div>
</div>
<p>On Linux systems you may need to install with root privileges using the <em>sudo</em> command.</p>
<p>After a successful install the Guidoc package and script will be available. On Linux they should be immediately accessible from your current search path. On Windows you will need to make sure that the <tt class="docutils literal"><span class="pre">&lt;Python</span> <span class="pre">root&gt;\Scripts</span></tt> directory is in your %PATH% environment variable.</p>
<p>If you can&#8217;t use the installer script, it is possible to use <tt class="docutils literal"><span class="pre">guidoc.py</span></tt> directly without installation and just distribute it along with your code. If you need to use this module from Python 3 you can manually convert it with the <tt class="docutils literal"><span class="pre">2to3</span></tt> tool:</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; 2to3 -w guidoc.py
</pre></div>
</div>
</div>
<div class="section" id="guidoc-specification-syntax">
<span id="docstring-specification"></span><h2>Guidoc specification syntax<a class="headerlink" href="#guidoc-specification-syntax" title="Permalink to this headline">¶</a></h2>
<p>The heart of using Guidoc is the layout specification. It is a string or separate file containing a description of the Tkinter GUI elements that will be generated.</p>
<p>A specification is composed of a sequence of sections. Each section begins with a line in square brackets containing the section type and an optional parameter. Section type names are case insensitive.</p>
<div class="figure align-center">
<img src="_images/syntax_section.svg" /><p class="caption">Widget section heading syntax</p>
</div>
<p>Sections can be in any order. There can be only one widgets section but any number of grid and menu sections are permitted. There is an implicit widgets section at the start of the specification so you can omit the &#8220;[widgets]&#8221; section heading and begin the widget definitions immediately.</p>
<p>You can have comments anywhere within the specification. They are started by a &#8220;#&#8221; character and extend to the end of the line.</p>
<div class="section" id="widgets-section">
<h3>Widgets section<a class="headerlink" href="#widgets-section" title="Permalink to this headline">¶</a></h3>
<p>All of the widgets to be created in the layout are listed in the widgets section, one widget per line. An indented widget is the child of the parent widget at the previous indentation level. Tabs are not recognized as indentation, only spaces. Blank lines are ignored. They don&#8217;t affect the hierarchy. A widget specification consists of the following:</p>
<div class="figure align-center">
<img src="_images/syntax_widget.svg" /><p class="caption">Widget specification syntax</p>
</div>
<p>Every widget name becomes an instance attribute of the class that the layout will be inserted into. They must be a valid Python identifier. The class must be a visible Tkinter widget class or a custom class with a standard Tkinter <tt class="docutils literal"><span class="pre">config()</span></tt> method. The optional parameters are a list of Python keyword arguments that would be valid for the widget constructor or its <tt class="docutils literal"><span class="pre">config()</span></tt> method.</p>
<p>All parameters must be a comma separated list in &#8220;&lt;key&gt;=&lt;value&gt;&#8221; format as positional parameters are not supported. Complex arguments requiring more than one line can be reserved for manual calls to the widget <tt class="docutils literal"><span class="pre">config()</span></tt> method after <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> has initialized the widgets.</p>
<p>To illustrate, here is a frame containing a label and a button:</p>
<div class="highlight-python"><div class="highlight"><pre>myFrame(Frame)
  myButton(Button | text=&#39;Button text&#39;)
  myLabel(Label | text=&#39;Label text&#39;)
</pre></div>
</div>
<img alt="_images/basic_packed.png" src="_images/basic_packed.png" />
<p>These widgets expand into the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Widgets</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myFrame</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myFrame</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myButton</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">myFrame</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Button text&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myButton</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myLabel</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">myFrame</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Label text&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myLabel</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>
</pre></div>
</div>
<p>See how every widget becomes an attribute of the class. You can refer to them later in your own code that needs to alter the widgets, setup event bindings, etc. The frame has been used as the parent of the button and label based on their indentation. In more complex layouts you can easily revise the widget hierarchy without having to update the parent widgets since Guidoc handles it for you.</p>
<p>The Guidoc package will attempt to discover the name of the Tkinter library and prepend it onto any standard widgets. In this case it has been aliased to &#8220;tk&#8221;. You can override this with an optional parameter to the <tt class="docutils literal"><span class="pre">tk_layout</span></tt> decorator.</p>
<p>All widgets default to using the <tt class="docutils literal"><span class="pre">pack</span></tt> geometry manager. You can override the default by appending a geometry manager configuration to the end of the widget definition. This lets you pass configuration parameters or change to the <tt class="docutils literal"><span class="pre">grid</span></tt> or <tt class="docutils literal"><span class="pre">place</span></tt> managers if needed. It has the following syntax:</p>
<div class="figure align-center">
<img src="_images/syntax_widget_geometry.svg" /><p class="caption">Geometry manager configuration syntax</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The parameters to a widget class are copied directly into the generated code without any attempt to parse them. The parameters to the geometry manager, however, need to be parsed so that the grid sections can override row and column settings. This parsing is crude and you need to avoid any complex Python syntax that can&#8217;t be handled.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre># Pack widgets horizontally
myFrame(Frame)
  myButton(Button | text=&#39;Button text&#39;) &lt;pack | side=&#39;left&#39;&gt;
  myLabel(Label | text=&#39;Label text&#39;, bg=&#39;red&#39;) &lt;pack | side=&#39;left&#39;&gt;
</pre></div>
</div>
<img alt="_images/basic_pack_horiz.png" src="_images/basic_pack_horiz.png" />
<div class="highlight-python"><div class="highlight"><pre># Manually put widgets into a grid
myFrame(Frame)
  myButton(Button | text=&#39;Button text&#39;) &lt;grid | row=0, column=0&gt;
  myLabel(Label | text=&#39;Label text&#39;, bg=&#39;red&#39;) &lt;grid | row=1, column=1&gt;
</pre></div>
</div>
<img alt="_images/basic_grid.png" src="_images/basic_grid.png" />
</div>
<div class="section" id="grid-sections">
<h3>Grid sections<a class="headerlink" href="#grid-sections" title="Permalink to this headline">¶</a></h3>
<p>Grid sections serve as a supplement to the widgets defined in the widgets section. Each grid contains a table in one of the <a class="reference external" href="http://docutils.sourceforge.net/docs/user/rst/quickref.html#tables">two forms supported by the docutils package</a>. The grid table format permits cells to span multiple columns and rows. The simple table format only permits cells to span multiple columns.</p>
<p>Each grid cell in the table contains a single widget name corresponding to the names defined in the widgets section. Any nested <tt class="docutils literal"><span class="pre">Frame</span></tt> widgets can have their own grid sections with a table describing how their children are arranged.</p>
<div class="highlight-python"><div class="highlight"><pre>[grid frameL]    # Grid table format:

+------+------+
| lblA |      |
+------+ lblC |
| lblB |      |
+------+------+

[grid frameR]    # Simple table format:

# lblZ spans two columns
==== ====
lblX lblY
  lblZ
---------
==== ====
</pre></div>
</div>
<img alt="_images/gridded.png" src="_images/gridded.png" />
<p>The section parameter for the grid identifies which widget the grid applies to. This must be the name of a container widget that can serve as the parent to child widgets. These are <tt class="docutils literal"><span class="pre">Frame</span></tt> and <tt class="docutils literal"><span class="pre">Toplevel</span></tt> in the built in Tkinter classes. One grid section can have its parameter omitted in which case it applies to the top level widgets for the new class being defined in your code.</p>
<p>After the grid is parsed, all widgets identified in the grid are converted to use the grid geometry manager. The cell coordinates and row/column span data are added to the widget specifications. Any sibling widgets missing from the grid have their default geometry manager changed to grid as well and they will be stacked in additional rows under column one.</p>
<p>Sibling widgets that have been explicitly set to use the <tt class="docutils literal"><span class="pre">pack</span></tt> or <tt class="docutils literal"><span class="pre">place</span></tt> geometry managers will conflict with the use of the <tt class="docutils literal"><span class="pre">grid</span></tt> geometry manager. This will cause an exception and terminate parsing of the specification.</p>
</div>
<div class="section" id="menu-sections">
<h3>Menu sections<a class="headerlink" href="#menu-sections" title="Permalink to this headline">¶</a></h3>
<p>Menus can be described in a hierarchical fashion similar to widgets. Each menu section describes a single menu tree. A row in the menu specification describes a single menu item with the following syntax:</p>
<div class="figure align-center">
<img src="_images/syntax_menu.svg" /><p class="caption">Menu item syntax</p>
</div>
<p>The menu text must be quoted if it contains spaces. You can prefix a character with &#8220;&amp;&#8221; in the text to mark it as a keyboard accelerator. Check button menu items are preceded by &#8220;[]&#8221; and radio button items by &#8220;*&#8221;.</p>
<p>The menu section parameter serves as the class attribute the menu will be assigned to. One menu section can have its parameter omitted, in which case it will be called &#8220;menubar&#8221;. An attempt will be made to automatically configure this menu as the application menu bar if the class or its parent is an instance of <tt class="docutils literal"><span class="pre">Toplevel</span></tt>. All other menus must be manually configured to become visible.</p>
<p>Separator lines can be created with four or more &#8220;-&#8221; characters in sequence.</p>
<p>For check and radio button items you will want to use the appropriate Tkinter variable objects to store their state. Radio items sharing the same variable are linked together. Menu rows that are the parent to a set of child items should have no parameters.</p>
<div class="highlight-python"><div class="highlight"><pre>[menu]

&amp;File
  &amp;Open  command=...
  &amp;Save  command=...
&amp;Settings
  [] &#39;Check 1&#39;  variable=self.Check1Val
  [] &#39;Check 2&#39;  variable=self.Check2Val
  ----
  * &#39;Radio 1&#39;   variable=self.RadioVal, value=&#39;1&#39;
  * &#39;Radio 2&#39;   variable=self.RadioVal, value=&#39;2&#39;
  * &#39;Radio 3&#39;   variable=self.RadioVal, value=&#39;3&#39;
&amp;Help
  &amp;About  command=...

...
# Elsewhere in your Python code:

self.Check1Val = tk.IntVar()
self.Check2Val = tk.IntVar()

self.RadioVal = tk.StringVar()
self.RadioVal.set(&#39;1&#39;)  # Initialize the value
</pre></div>
</div>
<img alt="_images/menu.png" src="_images/menu.png" />
<p>With a menu bar, the first level of hierarchy becomes the top level menu. Subsequent levels are pull down cascade menus. Each cascade menu has its tearoff property disabled for a more up to date rendering style.</p>
</div>
</div>
<div class="section" id="using-the-decorator">
<h2>Using the decorator<a class="headerlink" href="#using-the-decorator" title="Permalink to this headline">¶</a></h2>
<p>You use the <tt class="docutils literal"><span class="pre">tk_layout</span></tt> class decorator to dynamically generate the layout method. It modifies the class object by inserting a new <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> method. <tt class="docutils literal"><span class="pre">tk_layout</span></tt> is called with the following parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>layout</dt>
<dd>The layout specification. This is the only required parameter. It can be provided in place as a docstring. Use a raw docstring if you need to embed escaped characters.</dd>
<dt>lib_prefix</dt>
<dd>The Python library prefix to prepend on widget constructors</dd>
<dt>libraries</dt>
<dd>Dictionary of of library packages referenced in the specification. This can be generated with the <tt class="docutils literal"><span class="pre">lib_imports()</span></tt> function.</dd>
<dt>method_name</dt>
<dd>The name of the method to generate. This defaults to &#8220;_build_widgets&#8221;</dd>
<dt>layout_file</dt>
<dd>An optional path to a text file with the layout specification. Only used when layout is empty.</dd>
<dt>require_docutils</dt>
<dd>Raise a <tt class="docutils literal"><span class="pre">GridError</span></tt> exception when docutils is not present and a grid section is in a specification. This defaults to False.</dd>
</dl>
</div></blockquote>
<p>The decorator is used on the widget subclass you create for your program. This class should inherit from any Tkinter container widget such as <tt class="docutils literal"><span class="pre">Frame</span></tt> or <tt class="docutils literal"><span class="pre">Toplevel</span></tt>. It is only ran once before Python creates the class object, parsing the specification and inserting the generated method. After that no part of Guidoc will execute in your program.</p>
<p>If you want to refer to widgets outside of the Tkinter/tkinter package it is necessary to provide their packages as the <tt class="docutils literal"><span class="pre">libraries</span></tt> argument. Otherwise the Guidoc module can&#8217;t see them when it compiles the layout specification into a code object. The <tt class="docutils literal"><span class="pre">lib_imports()</span></tt> helper function will scan your application&#8217;s namespace for all imported packages and generate the <tt class="docutils literal"><span class="pre">dict</span></tt> used by this argument. You must pass in the contents of the <tt class="docutils literal"><span class="pre">globals()</span></tt> <tt class="docutils literal"><span class="pre">dict</span></tt> for it to search the packages.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">mywidgets</span> <span class="kn">as</span> <span class="nn">mw</span>  <span class="c"># Using widgets from a separate package</span>
<span class="kn">from</span> <span class="nn">guidoc</span> <span class="kn">import</span> <span class="n">tk_layout</span><span class="p">,</span> <span class="n">lib_imports</span>

<span class="nd">@tk_layout</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">myButton(mw.Button | text=&#39;Custom&#39;)</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">libraries</span><span class="o">=</span><span class="n">lib_imports</span><span class="p">(</span><span class="nb">globals</span><span class="p">()))</span>
<span class="k">class</span> <span class="nc">MyApp</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>It you want the layout stored in a separate file you can use the <tt class="docutils literal"><span class="pre">layout_file</span></tt> agument to access it.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@tk_layout</span><span class="p">(</span><span class="n">layout_file</span><span class="o">=</span><span class="s">&#39;my_layout.txt&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyDialog</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">)</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Your <tt class="docutils literal"><span class="pre">__init__</span></tt> method should instantiate any Tkinter variables needed by the <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> method. After calling the method you can continue to configure the widgets with event bindings and other activities.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@tk_layout</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s"># Your layout specification goes here</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyDialog</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

    <span class="c"># Create any necessary Tkinter variables here</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_build_widgets</span><span class="p">()</span>

    <span class="c"># Finish configuring the widgets and menus here</span>
</pre></div>
</div>
<p id="command-line-tool-for-static-code-generation">The original layout string is accessible through the <tt class="docutils literal"><span class="pre">_guidoc</span></tt> attribute of the class. The <tt class="docutils literal"><span class="pre">dump_layouts()</span></tt> convenience function will scan a namespace for any objects containing this attribute and write the value out to a file &#8220;&lt;object name&gt;.guidoc&#8221;. This can help automate generation of static <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">guidoc</span> <span class="kn">import</span> <span class="n">dump_layouts</span>

<span class="n">dump_layouts</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span> <span class="c"># Dump all layouts available within the current module</span>
</pre></div>
</div>
</div>
<div class="section" id="static-generation">
<h2>Static generation<a class="headerlink" href="#static-generation" title="Permalink to this headline">¶</a></h2>
<p>If you wish to distribute code without a dependency on Guidoc it is possible to statically generate the <tt class="docutils literal"><span class="pre">_build_widgets()</span></tt> method for insertion into your code. The easiest way is to use <tt class="docutils literal"><span class="pre">guidoc</span></tt> module on the command line with the <tt class="docutils literal"><span class="pre">-i</span></tt> option. It outputs the generated Python code to stdout.</p>
<div class="highlight-sh"><div class="highlight"><pre>&gt; guidoc -i layout_spec.txt &gt; build_method.py
&gt; cat layout_spec.txt <span class="p">|</span> guidoc -i - &gt; build_method.py
</pre></div>
</div>
<p>You can also generate the code from within Python. The function <tt class="docutils literal"><span class="pre">create_layout_method()</span></tt> generates the Python code for the layout.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">guidoc</span> <span class="kn">import</span> <span class="n">create_layout_method</span>

<span class="o">...</span>

<span class="n">spec</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">  # Layout specification here</span>
<span class="s">&#39;&#39;&#39;</span>

<span class="n">py_code</span> <span class="o">=</span> <span class="n">create_layout_method</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s">&#39;_build_widgets&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is possible to create an application that automatically switches between the dynamic layout built from a specification and a fixed static method based on the availability of Guidoc. When Guidoc is missing you define a dummy <tt class="docutils literal"><span class="pre">tk_layout()</span></tt> decorator that does nothing. In this way you can keep the <tt class="docutils literal"><span class="pre">tk_layout()</span></tt> decorator in place for documentation purposes and still distribute an application that is not dependent on Guidoc.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Tkinter</span> <span class="kn">as</span> <span class="nn">tk</span>

<span class="c"># Create a dummy decorator if Guidoc is missing</span>
<span class="k">try</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">guidoc</span> <span class="kn">import</span> <span class="n">tk_layout</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">tk_layout</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">cls</span><span class="p">:</span> <span class="n">cls</span>

<span class="nd">@tk_layout</span><span class="p">(</span><span class="s">&#39;&#39;&#39;btnTest(Button | text=&quot;Guidoc button&quot;)&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyApp</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="n">tk</span><span class="o">.</span><span class="n">Frame</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_build_widgets</span><span class="p">()</span>

  <span class="c"># This method is replaced by the real tk_layout decorator when Guidoc is available</span>
  <span class="k">def</span> <span class="nf">_build_widgets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># Your static widget code here</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">btnTest</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s">&#39;Static button&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">btnTest</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>


<span class="n">root</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">Tk</span><span class="p">()</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>
<span class="n">root</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>
</div>
<p>Any helper functions you use will also need to have a dummy substitude created.</p>
</div>
<div class="section" id="error-handling">
<h2>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>Guidoc code is only executed once at application startup for each decorated class. All error conditions are reported through exceptions. Invalid syntax in the widget, grid, and menu sections will raise an exception with some explanatory text descirbing the issue. If you depend on the grid parsing from docutils you can set the <tt class="docutils literal"><span class="pre">require_docutils</span></tt> argument of <tt class="docutils literal"><span class="pre">tk_layout()</span></tt> to <tt class="docutils literal"><span class="pre">True</span></tt> to force a <tt class="docutils literal"><span class="pre">GridException</span></tt> to be raised when the library is missing. You must resolve all exceptions before the application can produce a usable layout method.</p>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="#">
              <img class="logo" src="_static/guidoc_icon.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="#">Guidoc</a></h1>



<p class="blurb">Tkinter gui generator</p>



<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kevinpt&repo=guidoc&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>


<div id="download_links">
  <div class="js-clone-url clone-url open" data-protocol-type="http">
    <span>Git clone URL:</span>
    <div>
      <input type="text" value="https://github.com/kevinpt/guidoc.git"
             onclick="this.focus();this.select()" readonly="readonly" aria-label="Git clone URL">
    </div>
  </div>
  <br>
</div><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Guidoc</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#licensing">Licensing</a></li>
<li><a class="reference internal" href="#download">Download</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#guidoc-specification-syntax">Guidoc specification syntax</a><ul>
<li><a class="reference internal" href="#widgets-section">Widgets section</a></li>
<li><a class="reference internal" href="#grid-sections">Grid sections</a></li>
<li><a class="reference internal" href="#menu-sections">Menu sections</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-decorator">Using the decorator</a></li>
<li><a class="reference internal" href="#static-generation">Static generation</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>
<h3>Other projects</h3>

<div id="proj_list">
<p>
<a href="http://kevinpt.github.io/opbasm/">Opbasm</a><br>
<a href="http://kevinpt.github.io/ripyl/">Ripyl</a><br>
<a href="http://code.google.com/p/vertcl">Vertcl</a><br>
<a href="http://code.google.com/p/vhdl-extras">Vhdl-extras</a><br>
<a href="http://kevinpt.github.io/lecroy-colorizer/">Lecroy-colorizer</a>
</p>
</div>

<script>
$(function() { // Retrieve list of repositories from Github and dynamically insert them into sidebar

if(!window.sessionStorage || !JSON) { return; } // Punt on crusty browsers (looking at you IE10)

function JSONP( url, callback ) {
	var id = ( 'jsonp' + Math.random() * new Date() ).replace('.', '');
	var script = document.createElement('script');
	script.src = url.replace( 'callback=?', 'callback=' + id );
	document.body.appendChild( script );
	window[ id ] = function( data ) {
		if (callback) {
			callback( data );
		}
	};
}

// Build dictionary indexing lower cased project names with their preferred format
var knownProjects = ["VHDL-extras", "Ripyl", "VerTcl", "LeCroy-colorizer", "Opbasm"];
var projectDict = {};
$.each(knownProjects, function(index, v) {
  projectDict[v.toLowerCase()] = v;
});

function insert_projects(projects) {
    var links = [];
    var cur_proj = "Guidoc".toLowerCase();
    
    $.each(projects, function(key, value) {
      if(key != cur_proj) {
        var title;
        if(key in projectDict) {
          title = projectDict[key];
        } else { // Capitalize first char
          title = key.replace(/^./, function(match) {return match.toUpperCase()});
        }
        links.push("<a href='"+ value +"'>" + title + "</a>");
      }
    });
    
    $("#proj_list").html("<p>"+ links.join("<br>") +"</p>");
}

var now = new Date().getTime();
if(sessionStorage.KTcacheTime && now - sessionStorage.KTcacheTime < 5*60*1000 ) { // Use cached values (5 min. expiry)
  insert_projects(JSON.parse(sessionStorage.KTprojects));
} else { // Retrieve current projects
  JSONP("https://api.github.com/users/kevinpt/repos?type=owner&callback=?", function(response) {
    var projects = {};
    $.each(response.data, function(index, value) {
      if(!value.fork)
        projects[value.name] = value.homepage;
    });
    
    insert_projects(projects);
    
    // Store data in session cache
    sessionStorage.KTprojects = JSON.stringify(projects);
    var now = new Date().getTime();
    sessionStorage.KTcacheTime = now;
  });  
}

});
</script>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      &copy;2016, Kevin Thibedeau.
      
      |
      <a href="_sources/index.txt"
          rel="nofollow">Page source</a>
    </div>

    

    

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-82094459-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>